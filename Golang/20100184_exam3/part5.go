package main

import (
	"os"
	"fmt"
    // "reflect"
	"encoding/binary"
)


func lookup(codes []int, palette [][3]uint8) []uint8 {
    ret := make([]uint8, 0)
    for i:= 0; i < len(codes); i++{
        ret = append(ret, palette[codes[i]][2], palette[codes[i]][1], palette[codes[i]][0])
    }
    return ret
}
/* Part 3: Decompress the GIF codes to color codes
In this part, you are given a list of GIF codes and you will produce color codes that are then used by the lookup function you wrote in part 1/2. You will get a dictionary (actually a 2D array) that you need to index using the GIF codes. However, unlike parts 1/2 the number of color codes against a GIF code is variable. So the size of the resulting array is not known in advance. To avoid repeated allocations (with make or append), you are required to first calculate the size of the output array (by going over all GIF codes and finding the length of color codes against each GIF code) and then do a single allocation (using make) and finally traverse to fill in the color codes.
*/
func decompress(codes []int, dict [][]int) []int {
    ret := make ([]int,0)
    for i:= 0; i< len(codes); i++{
        for j:= 0; j < len(dict[codes[i]]); j++{
            ret = append(ret, dict[codes[i]][j])
        }
    }
    return ret
}

/* Part 5: Generate the GIF dictionary
In this part, you are given a list of GIF codes (just like parts 3/4) and you will produce the GIF dictionary which was gien to you in parts 3/4. Dictionary generation is very simple. Initially the dictionary contains 258 entries. Entries 0-255 contain a 1-color array containing the corresponding color code e.g. an array containing just 0 at index 0, an array containing just 1 at index 1 and so on. The next two entries contain empty arrays. 

After that, for each of the GIF codes (EXCLUDING the first two), you will create a new dictionary entry containing ALL colors from the dictionary entry of the PREVIOUS code followed by ONE new color code:
 -> If the CURRENT GIF code is IN the dictionary, use the first element of its dictionary entry
 -> If the CURRENT GIF code is NOT in the dictionary, use the first element of the dictionary entry of the PREVIOUS code

As an example, you can see the dictionary given in the parts 3/4 generated for the corresponding GIF codes.
*/
func dictionary(codes []int) [][]int {
    ret:= make([][]int,0)
    for i:=0; i< 256;i++{
        temp:= make([]int, 1)
        temp[0] = i;
        ret = append(ret, temp)
    }
    temp:= make([]int, 0)
    ret= append(ret, temp,temp)
    for i:=2; i< len(codes);i++{
        temp:= make([]int,0)
        for j:= 0; j< len(ret[codes[i-1]]);j++{
            temp = append(temp, ret[codes[i-1]][j])
        }
        if codes[i] > len(ret) -1 {
            temp = append(temp, ret[codes[i-1]][0])
        } else {
            temp = append(temp, ret[codes[i]][0])
        }
        fmt.Println(temp)
        ret = append(ret, temp)
    }
    return ret
}

/* Part 6: Parallel Dictionary generation
You are to only divide the work in just two halves in this part (not recursively). We will also set the maximum dictionary size to exactly 4096 entries. The problem in this part is that dictionary entries on the right may depend on dictionary entries on the left that have not yet been written. Our solution is to make the dictionary an array of channels. You will start 4096 goroutines running the 'once' function (given below) for each channel in the dictionary. You can see that this goroutine will block anyone reading from the channel until a value is written and then it will indefinitely respond to readers. Now the goroutine handling the right half of the GIF codes can easily start its working as any value not available will block it until it becomes available. Make helper functions or lambda functions as the actual goroutines for the left and right halves.

Once you finish the task, see "out5.bmp" generated by the given main function which has the password for Part 7 
*/
func once(val [2]chan []int) {
    value := <-val[0]
    for {
        val[1]<- value
    }
}

func parallel_dictionary(codes []int) [][2]chan []int {
    dict := make([][2]chan[]int, 4096)
    return dict
}

func main() {
    part5_gif_dict := dictionary(part5_gif_codes)
    bmp("out5.bmp", lookup(decompress(part5_gif_codes, part5_gif_dict), part5_palette), 16, 8)

    part5_gif_parallel_dict := parallel_dictionary(part5_gif_codes)
    for i, x := range part5_gif_dict {
        if !reflect.DeepEqual(x, <-part5_gif_parallel_dict[i][1]) {
            fmt.Println("Parallel dictionary differs from sequential dictionary")
            break
        }
    }
    fmt.Println("Done")
}



// DO NOT WORRY ABOUT ANYTHING BELOW THIS LINE

func bmp(filename string, data []uint8, dimX, dimY uint16) {
    bmp, _ := os.Create(filename)
    defer bmp.Close()
    binary.Write(bmp, binary.LittleEndian, []byte{'B','M'})
    binary.Write(bmp, binary.LittleEndian, []int32{int32(54+len(data)), 0, 54, 40, int32(dimX), -1 * int32(dimY), 0x180001, 0, 0, 0, 0, 0, 0})
    binary.Write(bmp, binary.LittleEndian, data)
}

var part5_gif_codes = []int{
256, 251, 258, 259, 260, 261, 260, 250, 196, 262, 236, 203, 259, 249, 265, 243,
265, 261, 242, 268, 258, 188, 182, 147, 270, 250, 188, 209, 282, 188, 188, 276,
251, 270, 289, 196, 287, 251, 236, 265, 194, 288, 264, 251, 244, 187, 273, 275,
294, 288, 272, 289, 154, 236, 197, 251, 200, 311, 267, 259, 282, 147, 244, 265,
193, 203, 250, 187, 146, 195, 288}

var part5_palette = [][3]uint8{
[3]uint8{0,0,0}, [3]uint8{0,0,51}, [3]uint8{0,0,102}, [3]uint8{0,0,153},
[3]uint8{0,0,204}, [3]uint8{0,0,255}, [3]uint8{0,43,0}, [3]uint8{0,43,51},
[3]uint8{0,43,102}, [3]uint8{0,43,153}, [3]uint8{0,43,204}, [3]uint8{0,43,255},
[3]uint8{0,85,0}, [3]uint8{0,85,51}, [3]uint8{0,85,102}, [3]uint8{0,85,153},
[3]uint8{0,85,204}, [3]uint8{0,85,255}, [3]uint8{0,128,0}, [3]uint8{0,128,51},
[3]uint8{0,128,102}, [3]uint8{0,128,153}, [3]uint8{0,128,204}, [3]uint8{0,128,255},
[3]uint8{0,170,0}, [3]uint8{0,170,51}, [3]uint8{0,170,102}, [3]uint8{0,170,153},
[3]uint8{0,170,204}, [3]uint8{0,170,255}, [3]uint8{0,213,0}, [3]uint8{0,213,51},
[3]uint8{0,213,102}, [3]uint8{0,213,153}, [3]uint8{0,213,204}, [3]uint8{0,213,255},
[3]uint8{0,255,0}, [3]uint8{0,255,51}, [3]uint8{0,255,102}, [3]uint8{0,255,153},
[3]uint8{0,255,204}, [3]uint8{0,255,255}, [3]uint8{51,0,0}, [3]uint8{51,0,51},
[3]uint8{51,0,102}, [3]uint8{51,0,153}, [3]uint8{51,0,204}, [3]uint8{51,0,255},
[3]uint8{51,43,0}, [3]uint8{51,43,51}, [3]uint8{51,43,102}, [3]uint8{51,43,153},
[3]uint8{51,43,204}, [3]uint8{51,43,255}, [3]uint8{51,85,0}, [3]uint8{51,85,51},
[3]uint8{51,85,102}, [3]uint8{51,85,153}, [3]uint8{51,85,204}, [3]uint8{51,85,255},
[3]uint8{51,128,0}, [3]uint8{51,128,51}, [3]uint8{51,128,102}, [3]uint8{51,128,153},
[3]uint8{51,128,204}, [3]uint8{51,128,255}, [3]uint8{51,170,0}, [3]uint8{51,170,51},
[3]uint8{51,170,102}, [3]uint8{51,170,153}, [3]uint8{51,170,204}, [3]uint8{51,170,255},
[3]uint8{51,213,0}, [3]uint8{51,213,51}, [3]uint8{51,213,102}, [3]uint8{51,213,153},
[3]uint8{51,213,204}, [3]uint8{51,213,255}, [3]uint8{51,255,0}, [3]uint8{51,255,51},
[3]uint8{51,255,102}, [3]uint8{51,255,153}, [3]uint8{51,255,204}, [3]uint8{51,255,255},
[3]uint8{102,0,0}, [3]uint8{102,0,51}, [3]uint8{102,0,102}, [3]uint8{102,0,153},
[3]uint8{102,0,204}, [3]uint8{102,0,255}, [3]uint8{102,43,0}, [3]uint8{102,43,51},
[3]uint8{102,43,102}, [3]uint8{102,43,153}, [3]uint8{102,43,204}, [3]uint8{102,43,255},
[3]uint8{102,85,0}, [3]uint8{102,85,51}, [3]uint8{102,85,102}, [3]uint8{102,85,153},
[3]uint8{102,85,204}, [3]uint8{102,85,255}, [3]uint8{102,128,0}, [3]uint8{102,128,51},
[3]uint8{102,128,102}, [3]uint8{102,128,153}, [3]uint8{102,128,204}, [3]uint8{102,128,255},
[3]uint8{102,170,0}, [3]uint8{102,170,51}, [3]uint8{102,170,102}, [3]uint8{102,170,153},
[3]uint8{102,170,204}, [3]uint8{102,170,255}, [3]uint8{102,213,0}, [3]uint8{102,213,51},
[3]uint8{102,213,102}, [3]uint8{102,213,153}, [3]uint8{102,213,204}, [3]uint8{102,213,255},
[3]uint8{102,255,0}, [3]uint8{102,255,51}, [3]uint8{102,255,102}, [3]uint8{102,255,153},
[3]uint8{102,255,204}, [3]uint8{102,255,255}, [3]uint8{153,0,0}, [3]uint8{153,0,51},
[3]uint8{153,0,102}, [3]uint8{153,0,153}, [3]uint8{153,0,204}, [3]uint8{153,0,255},
[3]uint8{153,43,0}, [3]uint8{153,43,51}, [3]uint8{153,43,102}, [3]uint8{153,43,153},
[3]uint8{153,43,204}, [3]uint8{153,43,255}, [3]uint8{153,85,0}, [3]uint8{153,85,51},
[3]uint8{153,85,102}, [3]uint8{153,85,153}, [3]uint8{153,85,204}, [3]uint8{153,85,255},
[3]uint8{153,128,0}, [3]uint8{153,128,51}, [3]uint8{153,128,102}, [3]uint8{153,128,153},
[3]uint8{153,128,204}, [3]uint8{153,128,255}, [3]uint8{153,170,0}, [3]uint8{153,170,51},
[3]uint8{153,170,102}, [3]uint8{153,170,153}, [3]uint8{153,170,204}, [3]uint8{153,170,255},
[3]uint8{153,213,0}, [3]uint8{153,213,51}, [3]uint8{153,213,102}, [3]uint8{153,213,153},
[3]uint8{153,213,204}, [3]uint8{153,213,255}, [3]uint8{153,255,0}, [3]uint8{153,255,51},
[3]uint8{153,255,102}, [3]uint8{153,255,153}, [3]uint8{153,255,204}, [3]uint8{153,255,255},
[3]uint8{204,0,0}, [3]uint8{204,0,51}, [3]uint8{204,0,102}, [3]uint8{204,0,153},
[3]uint8{204,0,204}, [3]uint8{204,0,255}, [3]uint8{204,43,0}, [3]uint8{204,43,51},
[3]uint8{204,43,102}, [3]uint8{204,43,153}, [3]uint8{204,43,204}, [3]uint8{204,43,255},
[3]uint8{204,85,0}, [3]uint8{204,85,51}, [3]uint8{204,85,102}, [3]uint8{204,85,153},
[3]uint8{204,85,204}, [3]uint8{204,85,255}, [3]uint8{204,128,0}, [3]uint8{204,128,51},
[3]uint8{204,128,102}, [3]uint8{204,128,153}, [3]uint8{204,128,204}, [3]uint8{204,128,255},
[3]uint8{204,170,0}, [3]uint8{204,170,51}, [3]uint8{204,170,102}, [3]uint8{204,170,153},
[3]uint8{204,170,204}, [3]uint8{204,170,255}, [3]uint8{204,213,0}, [3]uint8{204,213,51},
[3]uint8{204,213,102}, [3]uint8{204,213,153}, [3]uint8{204,213,204}, [3]uint8{204,213,255},
[3]uint8{204,255,0}, [3]uint8{204,255,51}, [3]uint8{204,255,102}, [3]uint8{204,255,153},
[3]uint8{204,255,204}, [3]uint8{204,255,255}, [3]uint8{255,0,0}, [3]uint8{255,0,51},
[3]uint8{255,0,102}, [3]uint8{255,0,153}, [3]uint8{255,0,204}, [3]uint8{255,0,255},
[3]uint8{255,43,0}, [3]uint8{255,43,51}, [3]uint8{255,43,102}, [3]uint8{255,43,153},
[3]uint8{255,43,204}, [3]uint8{255,43,255}, [3]uint8{255,85,0}, [3]uint8{255,85,51},
[3]uint8{255,85,102}, [3]uint8{255,85,153}, [3]uint8{255,85,204}, [3]uint8{255,85,255},
[3]uint8{255,128,0}, [3]uint8{255,128,51}, [3]uint8{255,128,102}, [3]uint8{255,128,153},
[3]uint8{255,128,204}, [3]uint8{255,128,255}, [3]uint8{255,170,0}, [3]uint8{255,170,51},
[3]uint8{255,170,102}, [3]uint8{255,170,153}, [3]uint8{255,170,204}, [3]uint8{255,170,255},
[3]uint8{255,213,0}, [3]uint8{255,213,51}, [3]uint8{255,213,102}, [3]uint8{255,213,153},
[3]uint8{255,213,204}, [3]uint8{255,213,255}, [3]uint8{255,255,0}, [3]uint8{255,255,51},
[3]uint8{255,255,102}, [3]uint8{255,255,153}, [3]uint8{255,255,204}, [3]uint8{255,255,255},
[3]uint8{0,0,0}, [3]uint8{0,0,0}, [3]uint8{0,0,0}, [3]uint8{0,0,0}}
